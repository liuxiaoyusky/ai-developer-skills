---
name: dev-flow
description: 持久开发流程 - 管理开发任务的完整生命周期（识别→拆解→执行→测试→调试）。**自动激活**：开发任务、功能实现、代码编写时自动启动。触发场景："实现XXX"、"添加功能"、"开发XXX"、"写代码"、"做任务"、"开发"、"实现"。**5步闭环**：任务识别→分析拆解→执行→测试验证→错误处理。
alwaysActivate: true
---

# Dev Flow Skill

> **触发条件**（开发任务场景自动激活）：
> - 💻 **功能开发**："实现XXX"、"添加功能"、"开发XXX"、"写代码"、"实现"
> - ✅ **任务管理**："做任务"、"待办"、"todo"、"任务清单"
> - 🔄 **完整闭环**：任务识别 → 分析拆解（调用first-principles）→ 执行 → 测试验证 → 错误处理（调用dev-debug）
>
> **协作技能**：
> - dev-loop：多任务自动迭代（"开始迭代"触发），检测 `<promise>COMPLETE</promise>` 信号
> - dev-debug：测试失败时自动调用
> - first-principles：任务拆解时调用
> - dev-review：代码变更时自动激活

---

## 🎯 技能概述

这是一个**自动激活**的开发流程技能，用于管理所有开发相关任务。它提供：

1. **任务识别** - 自动读取 tasks.md，找到待处理或进行中的任务
2. **智能拆解** - 使用第一性原理判断任务是否需要进一步拆解
3. **详细规划** - 生成 task-details.md 和 task-details-test.md
4. **执行追踪** - 标记进度，持续更新任务状态
5. **测试验证** - 按照测试方案验证功能
6. **错误处理** - 自动调用 debug 技能，记录错题本

### 自动激活条件

本技能在以下场景**自动激活**（无需用户显式调用）：

- 🟡 **中等信号**：用户提出开发任务/功能需求
- 🟡 **中等信号**：用户询问"如何实现"、"需要做什么"
- 🟡 **中等信号**：用户提到"开发"、"实现"、"添加功能"
- 🟢 **弱信号**（不激活）：纯技术问题咨询、代码解释

**用户手动激活**：
- "使用 dev-flow 技能"
- "开始开发流程"
- "管理我的开发任务"

---

## 📋 文件结构

```
project-root/
├── tasks.md                 # 主任务清单（用户维护）
├── caution.md               # ⚠️ 注意事项（用户维护，启动时强制检测，不存在则创建）
├── task-details.md          # 当前任务的详细拆解（AI 维护）
├── task-details-test.md     # 当前任务的测试方案（AI 维护）
├── dev-flow.log             # 执行日志（AI 维护，实时追加）
└── .claude/
    └── debug-experiences/   # 调试经验（debug 技能维护）
```

**⚠️ 强制要求**：
- `caution.md` **必须存在**，不存在时 dev-flow **必须立即创建默认模板**
- 每次启动 dev-flow 时**必须读取并显示** caution.md 内容

### dev-flow.log 格式

实时记录执行过程，包含四类日志：

**1. 决策日志**（为什么这样选择）
```
[2025-01-30 11:32:15] [DECISION] Step 1: 任务识别
  → 找到任务"实现用户认证系统"
  → 优先级：无进行中任务，选择第一个待处理任务
```

**2. 行动日志**（做了什么）
```
[2025-01-30 11:32:20] [ACTION] Step 2: 任务分析
  → 调用 first-principles 技能
  → 分析结果：需要拆解为 6 个子任务
```

**3. 状态日志**（进度变化）
```
[2025-01-30 11:35:00] [STATUS] Step 3: 执行中
  → 子任务 2/6 (33%)
  → 当前：实现注册 API
```

**4. 错误日志**（失败和修复）
```
[2025-01-30 11:40:00] [ERROR] Step 4: 测试失败
  → 单元测试失败：testRegister()
  → 调用 debug 技能
  → 根因：密码验证逻辑错误
[2025-01-30 11:42:30] [FIXED] 修复完成
  → 修改文件：src/api/auth.js:45
  → 重新测试：✅ 通过
```

### tasks.md 格式（用户维护）

```markdown
# 开发任务清单

## 待处理 (TODO)

- [ ] 实现用户登录功能
- [ ] 添加数据导出功能
- [ ] 优化 API 性能

## 进行中 (IN PROGRESS)

- [ ] 修复支付模块 bug  # ← 如果有进行中任务，优先处理

## 已完成 (DONE)

- [x] 搭建项目基础架构
- [x] 配置开发环境
```

---

## 🔄 五步开发流程

### Step 1: 任务识别

**目标**：从 tasks.md 中找到当前要处理的任务

**执行流程**：

```bash
# 0. 强制检查 caution.md（必须执行）
尝试读取 caution.md

如果 caution.md 不存在：
  AI: "⚠️  检测到 caution.md 不存在，正在创建默认模板..."
  写入默认模板（见下方 caution.md 默认模板）
  AI: "✅ 已创建 caution.md
       请根据需要编辑此文件，添加必须遵守的规则。"

如果 caution.md 存在：
  读取并显示内容
  AI: "⚠️  注意事项（caution.md）：
       <显示完整内容>

       ⚠️ 以上规则必须严格遵守！"

# 1. 读取 tasks.md
Read tasks.md

# 2. 任务优先级判断（自动选择，严禁询问）
优先级顺序：
  1. 进行中 (IN PROGRESS) 的任务 → 直接进入 Step 3
  2. 待处理 (TODO) 中的第一个任务 → 进入 Step 2
  3. 如果没有任务 → 询问用户是否需要添加新任务

# 3. 显示任务（严禁询问确认，直接开始）
AI: "📋 找到任务：<任务描述>
     开始处理..."
```

**⚠️ 严禁行为**：
- ❌ **禁止询问用户确认** - 直接开始处理，无任何犹豫
- ❌ **禁止等待用户输入** - 自动选择第一个待处理任务
- ❌ **禁止跳过 caution.md 检查** - 每次启动必须检查
- ✅ 如果有多个任务，按顺序处理第一个

**caution.md 默认模板**：

```markdown
# ⚠️ 开发注意事项

## 强制规则

在此文件中添加开发过程中必须遵守的规则。这些规则将在每次 dev-flow 启动时显示。

## 示例规则

- 禁止未测试就标记任务完成
- 禁止直接修改核心配置文件
- 禁止提交包含 console.log 的代码
- 所有 API 变更必须更新文档

---
请根据项目需求修改上述内容。
```

**决策树**：

```
开始
  ↓
检查 caution.md 是否存在？
  ├─ NO → 创建默认模板 → 显示内容 → 继续
  └─ YES ↓
读取 caution.md → 显示内容 → 继续
  ↓
读取 tasks.md
  ↓
检查是否有"进行中"任务？
  ├─ YES → 显示任务 → 直接进入 Step 3（禁止询问）
  └─ NO  ↓
检查是否有"待处理"任务？
  ├─ YES → 显示第一个任务 → 直接进入 Step 2（禁止询问）
  └─ NO  ↓
询问用户是否添加新任务
```

---

### Step 2: 任务分析与拆解

**目标**：判断任务是否需要拆解，生成详细计划和测试方案

**2.1 任务清晰度判断**

**判断标准**：

```markdown
✅ **足够清晰**（直接执行）：
- 任务描述具体，有明确的验收标准
- 涉及文件 < 5 个
- 预计工作量 < 2 小时
- 不需要架构决策

示例：
- "添加用户注销按钮到导航栏"
- "修复 API 响应中的 CORS 错误"

❌ **需要拆解**（使用第一性原理）：
- 任务描述模糊，缺乏细节
- 涉及多个模块/子系统
- 需要架构设计或技术选型
- 预计工作量 > 2 小时

示例：
- "实现用户认证系统"  # 太宽泛
- "优化数据库性能"      # 缺乏具体目标
- "重构代码架构"        # 需要设计
```

**2.2 智能拆解流程（使用第一性原理）**

**调用 first-principles 技能**：

```
任务需要拆解
  ↓
调用 first-principles 技能
  ↓
第一性原理分析：
  1. 拆解到基本真理（核心目标是什么？）
  2. 质疑所有假设（哪些功能是必需的？）
  3. 从零重建方案（最小可行方案是什么？）
  ↓
生成 3-7 个子任务（按依赖关系排序）
  ↓
写入 task-details.md
```

**2.3 生成测试方案**

**测试策略**（至少 3 种）：

```markdown
### task-details-test.md 模板

# 测试方案：<任务名称>

## 1. 单元测试 (Unit Tests)
**目标**：验证核心逻辑正确性
**工具**：Jest / pytest / JUnit 等
**覆盖范围**：
- [ ] 核心函数的输入输出
- [ ] 边界条件和异常处理
- [ ] 状态变化逻辑

## 2. 集成/功能测试 (Integration Tests)
**目标**：验证功能正常工作
**方法**：
- [ ] 手动测试功能流程
- [ ] 验证与外部系统的交互
- [ ] 测试 API 接口

## 3. 启动和运行测试 (Startup Tests)
**目标**：确保应用可以正常启动
**验证项**：
- [ ] 应用可以启动无报错
- [ ] 前端页面可以正常加载
- [ ] 关键功能可以访问

## 4. 行为验证测试 (Behavior Tests)
**目标**：验证功能符合预期行为
**场景**：
- [ ] 正常场景：输入有效数据，验证输出
- [ ] 异常场景：输入无效数据，验证错误处理
- [ ] 边界场景：测试极限值

## 5. 性能/回归测试 (Performance Tests，可选)
**目标**：验证性能指标或防止功能退化
**指标**：
- [ ] 响应时间 < X ms
- [ ] 内存占用 < Y MB
- [ ] 通过现有测试套件
```

**2.4 生成详细任务文件**

**task-details.md 模板**：

```markdown
# 详细任务：<任务名称>

## 任务概述
- **原始任务**：<来自 tasks.md 的描述>
- **清晰度评估**：足够清晰 / 需要拆解
- **预计工作量**：X 小时

## 子任务列表（如果需要拆解）

### 子任务 1：[标题]
**状态**：pending / in_progress / completed
**描述**：...
**涉及文件**：...
**验收标准**：...

### 子任务 2：[标题]
**状态**：pending
**描述**：...

## 执行计划
1. 分析现有代码（阅读相关文件）
2. 实现核心功能
3. 添加错误处理
4. 编写/更新文档

## 涉及文件
- `src/components/UserAuth.jsx` - 需要修改
- `src/api/auth.js` - 需要添加新方法

## 依赖项
- 需要先完成：...
- 需要安装：...

## 验收标准
- [ ] 功能正常工作
- [ ] 通过所有测试
- [ ] 代码已提交

## 进度追踪
开始时间：YYYY-MM-DD HH:mm
当前子任务：子任务 1
完成度：0%
```

**写入文件**：

```bash
# 覆盖写入 task-details.md
Write task-details.md

# 覆盖写入 task-details-test.md
Write task-details-test.md
```

---

### Step 3: 执行任务

**目标**：按照 task-details.md 执行任务，实时更新进度

**执行流程**：

```markdown
## 3.1 预备阶段

### 读取相关文件
使用 Read 工具阅读：
- task-details.md 中的"涉及文件"
- 相关的配置文件
- 依赖的模块

### 理解现有实现
- 使用 Grep 搜索相关代码模式
- 使用 Glob 查找相关文件
- 了解项目结构和约定

## 3.2 执行阶段

### 按子任务顺序执行
对于每个子任务：
  1. 标记为 in_progress
  2. 执行实现（使用 Edit/Write 工具）
  3. 更新 task-details.md 中的进度
  4. 标记为 completed

### 进度更新格式
在 task-details.md 中更新：
```markdown
## 进度追踪
开始时间：YYYY-MM-DD HH:mm
当前子任务：子任务 2 / 共 5 个
完成度：40%（2/5 子任务完成）

最近更新：
- [✓] 子任务 1：实现用户登录 UI (已完成)
- [→] 子任务 2：实现 API 调用逻辑 (进行中)
- [ ] 子任务 3：添加错误处理
```

## 3.3 任务完成信号

当所有子任务完成后：
AI: "✅ 任务执行完成！
     完成子任务：5/5
     完成时间：YYYY-MM-DD HH:mm
     总耗时：X 小时

     接下来进入测试阶段 (Step 4)..."
```

**工具使用策略**：

```markdown
✅ 推荐工具：
- Read  - 阅读现有代码
- Edit  - 修改代码（优先使用）
- Write - 创建新文件
- Grep  - 搜索相关代码
- Glob  - 查找文件

❌ 避免使用：
- Bash echo - 使用文本回复代替
- sed/awk  - 使用 Edit 工具代替
```

---

### Step 4: 测试验证

**目标**：按照 task-details-test.md 验证功能

**测试执行流程**：

```markdown
## 4.1 读取测试方案

Read task-details-test.md

## 4.2 逐项测试（自动执行，不要询问）

### 对于每个测试项：

1. **单元测试**
   ```bash
   # 运行单元测试
   npm test

   # 或运行特定测试
   pytest tests/test_auth.py
   ```

   **结果判断**（自动判断，不要询问）：
   - ✅ 通过 → 继续下一个测试
   - ❌ 失败 → 进入 Step 5（调试）

2. **启动和运行测试**
   ```bash
   # 启动应用
   npm run dev

   # 或构建并运行
   npm run build && npm start
   ```

   **验证项**（自动检查）：
   - [ ] 应用启动无报错
   - [ ] 可以访问主页面
   - [ ] 浏览器控制台无错误

   **结果判断**：
   - ✅ 通过 → 继续下一个测试
   - ❌ 失败 → 进入 Step 5（调试）

3. **功能行为测试**
   ```bash
   # 手动测试或使用自动化测试
   # 验证功能符合预期
   ```

   **验证项**：
   - [ ] 正常场景测试
   - [ ] 异常场景测试
   - [ ] 边界条件测试

   **结果判断**：
   - ✅ 通过 → 继续下一个测试
   - ❌ 失败 → 进入 Step 5（调试）

**⚠️ 严禁行为**：
- ❌ **禁止等待用户确认** - 自动执行所有测试
- ❌ **禁止在每个测试步骤暂停** - 连续执行
- ❌ **禁止未测试就标记完成** - 必须完成所有测试步骤
- ✅ 如果所有测试通过 → 自动更新 tasks.md
- ✅ 如果有测试失败 → 自动进入 Step 5
- ✅ **必须输出完成信号**：`<promise>COMPLETE</promise>`（供 dev-loop 检测）

## 4.3 测试结果汇总

AI: "📊 测试结果汇总：

     ✅ 单元测试：通过 (15/15)
     ✅ 启动测试：通过
     ✅ 功能测试：通过 (8/8 测试场景)

     总体结果：全部通过 ✓

     任务完成！已更新 tasks.md

     <promise>COMPLETE</promise>"
```

**更新 tasks.md**：

```markdown
# 在 tasks.md 中移动任务

## 进行中 (IN PROGRESS)
(移除已完成的任务)

## 已完成 (DONE)
- [x] <完成的任务描述>  # 完成时间：YYYY-MM-DD
```

---

### Step 5: 错误处理与调试

**目标**：当测试失败时，系统化地解决问题

**触发条件**：
- Step 4 中任意测试失败
- 运行时错误/异常
- 功能不符合预期

**执行流程**：

```markdown
## 5.1 错误分类

检测到错误，进入调试流程：

1. **记录错误信息**
   ```markdown
   ### task-details-test.md（追加）

   ## 错误记录

   ### 错误 1
   **时间**：YYYY-MM-DD HH:mm
   **测试项**：单元测试 - 测试登录功能
   **错误信息**：...
   **堆栈跟踪**：...
   **复现步骤**：...
   ```

2. **自动激活 debug 技能**
   ```
   调用 debug 技能，提供以下信息：
   - 错误描述
   - 错误日志
   - 当前任务上下文
   ```

## 5.2 Debug 执行

Debug 技能将：
1. 使用 5 Whys 或第一性原理分析根因
2. 提供解决方案
3. 自动记录到 `.claude/debug-experiences/`

## 5.3 修复验证

修复后重新运行测试：
```bash
# 重新运行失败的测试
npm test -- --testNamePattern="failing test"

# 或重新运行所有测试
npm test
```

**循环**：
- 如果修复成功 → 返回 Step 4 继续测试
- 如果仍然失败 → 重复 Step 5

## 5.4 完成信号

AI: "🔧 问题已修复！

     根因：...
     解决方案：...
     已记录到错题集：.claude/debug-experiences/YYYY-MM-DD-issue.md

     重新测试中...
     ✅ 所有测试通过

     返回 Step 4 继续验证..."
```

---

## 🎯 完整流程图

```
┌─────────────────────────────────────────────────────────────┐
│                    用户请求/自动激活                          │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 1: 任务识别                                            │
│  ├─ 读取 tasks.md                                            │
│  ├─ 优先级判断 (IN PROGRESS > TODO)                          │
│  └─ 确认任务                                                 │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 2: 任务分析与拆解                                      │
│  ├─ 判断清晰度                                               │
│  ├─ 如果需要拆解 → 调用 first-principles                     │
│  ├─ 生成 task-details.md                                     │
│  └─ 生成 task-details-test.md                                │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 3: 执行任务                                            │
│  ├─ 按子任务顺序执行                                         │
│  ├─ 实时更新进度                                             │
│  └─ 标记完成状态                                             │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 4: 测试验证                                            │
│  ├─ 读取 task-details-test.md                                │
│  ├─ 逐项执行测试                                             │
│  ├─ 如果全部通过 → 完成，更新 tasks.md                       │
│  └─ 如果有失败 → 进入 Step 5                                 │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 5: 错误处理                                            │
│  ├─ 记录错误信息                                             │
│  ├─ 调用 debug 技能                                          │
│  ├─ 修复问题                                                 │
│  └─ 返回 Step 4 重新测试                                     │
└─────────────────────────────────────────────────────────────┘
```

---

## 📝 使用示例

### 示例 1：清晰任务（无需拆解）

**用户**：帮我添加一个用户注销按钮

**AI 流程**：

```
Step 1: 读取 tasks.md
  → 找到任务："- [ ] 添加用户注销按钮"
  → 直接开始（不询问确认）

Step 2: 判断清晰度
  → 任务描述具体，涉及文件少
  → 评估：足够清晰，无需拆解
  → 生成 task-details.md（单任务）
  → 生成 task-details-test.md

Step 3: 执行任务
  → 读取导航栏组件
  → 添加注销按钮
  → 实现注销逻辑
  → 更新进度：100%

Step 4: 测试验证（自动执行，不询问）
  → 运行单元测试：✅ 通过
  → 启动应用：✅ 正常
  → 手动测试注销功能：✅ 正常

  → 更新 tasks.md：移动到 DONE
  → 输出完成信号：<promise>COMPLETE</promise>
```

### 示例 2：复杂任务（需要拆解）

**用户**：帮我实现用户认证系统

**AI 流程**：

```
Step 1: 读取 tasks.md
  → 找到任务："- [ ] 实现用户认证系统"
  → 直接开始（不询问确认）

Step 2: 判断清晰度
  → 任务描述宽泛，涉及多个模块
  → 评估：需要拆解

  → 调用 first-principles 技能

  → 第一性原理分析：
      基本真理：
      - 认证的核心目标是验证用户身份
      - 最小可行方案：注册 + 登录 + 注销

      质疑假设：
      - 是否需要社交登录？→ MVP 不需要
      - 是否需要双因素认证？→ MVP 不需要
      - 是否需要密码重置？→ 暂时不需要

      重建方案：
      1. 设计数据库表结构（users 表）
      2. 实现注册 API
      3. 实现登录 API
      4. 实现前端认证表单
      5. 实现注销功能
      6. 添加认证中间件

  → 生成 task-details.md（6 个子任务）
  → 生成 task-details-test.md

Step 3: 执行任务
  → 子任务 1：设计数据库表结构 [in_progress]
  → 子任务 1：设计数据库表结构 [completed]
  → 子任务 2：实现注册 API [in_progress]
  → 子任务 2：实现注册 API [completed]
  → ... (继续执行)

Step 4: 测试验证（自动执行，不询问）
  → 单元测试：✅ 通过
  → 集成测试：❌ 失败
  → 自动进入 Step 5

Step 5: 错误处理
  → 调用 debug 技能
  → 根因分析：API 响应格式不匹配
  → 修复问题
  → 返回 Step 4 重新测试

  → 所有测试通过 ✅
  → 更新 tasks.md：移动到 DONE
  → 输出完成信号：<promise>COMPLETE</promise>
```

---

## 🔧 dev 技能生态

**dev 技能生态**是一套相互配合的开发技能集合，覆盖从任务管理到代码质量保障的完整开发流程。

### 生态成员

```
dev 技能生态
├── dev-flow          # 持久开发流程（核心引擎）
├── dev-loop          # 自动迭代调度器
├── dev-debug         # 问题解决技能
└── dev-review        # 代码审查技能

协作技能
├── first-principles  # 第一性原理思维
└── first-principles-planner  # 产品设计应用
```

### 各技能职责

#### 1. dev-flow（核心引擎）

**职责**：管理单个任务的完整生命周期

**触发方式**：
- 自动激活：所有开发相关任务
- 手动调用：`claude "使用 dev-flow 技能"`

**核心流程**（5 步闭环）：
1. 任务识别 - 读取 tasks.md
2. 分析拆解 - 调用 first-principles
3. 执行实现 - 实时更新进度
4. 测试验证 - 按测试方案验证
5. 错误处理 - 调用 dev-debug

**输出**：
- `task-details.md` - 任务拆解详情
- `task-details-test.md` - 测试方案
- `dev-flow.log` - 执行日志

---

#### 2. dev-loop（迭代调度器）

**职责**：循环调用 dev-flow 完成所有任务

**触发方式**：
- 手动调用：`claude "开始迭代"` / `"启动 loop"` / `"dev loop"`
- 脚本运行：`node loop.js`

**核心逻辑**（5 行代码）：
```javascript
while (tasks.md 中有待处理任务) {
  claude "使用 dev-flow 技能处理下一个任务"
}
```

**迭代语义**：
```
1 次迭代 = 1 次 CLI 调用 = 1 次 dev-flow 执行（5 步闭环）
```

---

#### 3. dev-debug（问题解决）

**职责**：系统化调试和根因分析

**触发方式**：
- 自动激活：dev-flow 测试失败时调用
- 手动调用：`claude "调试这个问题"` / `"使用 dev-debug"`

**核心能力**：
- 5 Whys 根因分析
- 第一性原理重建
- 错题集管理（`.claude/debug-experiences/`）

---

#### 4. dev-review（代码审查）

**职责**：基于 Linus 思维的代码质量评估

**触发方式**：
- **默认启用**：代码审查/编写/API设计时自动激活
- 手动调用：`claude "审查这段代码"`

**分析框架**（5 层）：
1. 数据结构设计
2. 边界情况处理
3. 复杂度评估
4. 破坏性检查
5. 实用性验证

**智能建议**：
- 复杂任务（5+文件/500+行）时自动建议使用 dev-loop + dev-flow

---

#### 5. first-principles（思维工具）

**职责**：第一性原理任务拆解

**触发方式**：
- 自动激活：dev-flow 判断需要拆解时调用
- 手动调用：`claude "用第一性原理分析"`

**应用场景**：
- 复杂任务拆解
- 创新方案设计
- 技术决策验证

### 技能协作关系

```
┌─────────────────────────────────────────────────────────┐
│              dev 技能生态协作流程                        │
└─────────────────────────────────────────────────────────┘

长期项目（多任务）
    │
    ▼
┌───────────────┐
│   dev-loop    │  ← 循环调度
│  (迭代器)      │
└───────┬───────┘
        │ 调用
        ▼
┌───────────────┐
│   dev-flow    │  ← 执行引擎
│  (5步闭环)     │
└───────┬───────┘
        │
        ├─ 需要拆解 ──→ ┌─────────────────┐
        │               │first-principles │
        │               └─────────────────┘
        │
        ├─ 测试失败 ──→ ┌─────────────────┐
        │               │   dev-debug     │
        │               └─────────────────┘
        │
        └─ 代码变更 ──→ ┌─────────────────┐
                        │   dev-review    │
                        │  (自动激活)      │
                        └─────────────────┘
```

### 使用场景指南

| 场景 | 推荐技能 | 命令示例 |
|------|---------|---------|
| **单次开发任务** | dev-flow | `claude "使用 dev-flow 技能"` |
| **长期项目** | dev-loop → dev-flow | `node loop.js` |
| **遇到 bug** | dev-debug | `claude "使用 dev-debug 调试"` |
| **代码审查** | dev-review | `claude "审查这段代码"` |
| **任务拆解** | first-principles | `claude "用第一性原理分析"` |
| **复杂项目** | dev-loop + 全栈 | `node loop.js`（自动调用其他技能） |

### 最佳实践

#### ✅ 强制要求

1. **单次任务**：直接使用 dev-flow
   ```bash
   claude "使用 dev-flow 技能实现用户认证"
   ```

2. **长期项目**：使用 dev-loop 自动迭代
   ```bash
   # 1. 创建 tasks.md
   cp templates/TASKS.template.md tasks.md

   # 2. 添加任务到 tasks.md

   # 3. 运行自动迭代
   node loop.js
   ```

3. **遇到问题**：dev-flow 会自动调用 dev-debug
   - 无需手动激活
   - 自动记录到错题集

4. **代码审查**：dev-review 自动激活
   - 代码编写时自动应用 Linus 思维
   - 无需显式调用

#### ❌ 严禁行为

1. **禁止手动管理调用关系** - dev-flow 会自动决定何时调用其他技能
2. **禁止跳过测试** - dev-flow 强制要求测试验证
3. **禁止未测试就标记完成** - 所有任务必须完成测试步骤
4. **禁止忽略日志** - `dev-flow.log` 包含完整的执行过程
5. **禁止过度拆分** - first-principles 会判断是否需要拆解

### 迭代流程详解

```
dev-loop 启动
    │
    ├─ 检查 tasks.md
    │
    ├─ 找到待处理任务
    │
    ├─ 调用 dev-flow
    │   │
    │   ├─ Step 1: 任务识别
    │   │   └─ 记录到 dev-flow.log
    │   │
    │   ├─ Step 2: 分析拆解
    │   │   ├─ 需要拆解 → 调用 first-principles
    │   │   └─ 生成 task-details.md
    │   │
    │   ├─ Step 3: 执行实现
    │   │   ├─ dev-review 自动审查（代码变更）
    │   │   └─ 实时更新进度
    │   │
    │   ├─ Step 4: 测试验证
    │   │   └─ 按测试方案验证
    │   │
    │   └─ Step 5: 错误处理
    │       ├─ 测试失败 → 调用 dev-debug
    │       │   ├─ 5 Whys 根因分析
    │       │   ├─ 提供解决方案
    │       │   └─ 记录到错题集
    │       │
    │       ├─ 修复 → 返回 Step 4
    │       └─ 成功 → 更新 tasks.md
    │
    ├─ 检查 tasks.md
    │
    └─ 还有待处理？ → 是 → 继续下一次迭代
                  │
                  └─ 否 → 结束
```

### 架构优势

| 维度 | 传统方式 | dev 技能生态 |
|------|---------|------------|
| **流程标准化** | ❌ 随意性强 | ✅ 5 步固定流程 |
| **可调试性** | ❌ 难以追踪 | ✅ dev-flow.log |
| **错误处理** | ❌ 手动调试 | ✅ 自动调用 dev-debug |
| **任务拆解** | ❌ 依赖经验 | ✅ first-principles |
| **代码质量** | ❌ 事后审查 | ✅ dev-review 实时审查 |
| **测试验证** | ❌ 可能跳过 | ✅ 强制测试 |
| **可恢复性** | ❌ 状态混乱 | ✅ 状态清晰持久化 |
| **长期项目** | ❌ 难以维护 | ✅ dev-loop 自动迭代 |

**关键设计原则**：
- ✅ **单一职责**：每个技能专注一个领域
- ✅ **开闭原则**：可独立扩展任一技能
- ✅ **接口隔离**：按需使用，不强制依赖
- ✅ **依赖倒置**：dev-flow 依赖抽象的技能接口

---

## 📊 执行日志系统

### 日志机制

**⚠️ 强制要求**：Dev Flow 在执行过程中**必须实时追加日志**到 `dev-flow.log`，包含：

**1. 决策日志**（为什么）
```
[2025-01-30 11:32:15] [DECISION] Step 1: 任务识别
  → 找到任务"实现用户认证系统"
  → 理由：无进行中任务，选择第一个待处理任务
```

**2. 行动日志**（做了什么）
```
[2025-01-30 11:32:20] [ACTION] Step 2: 任务分析
  → 调用 first-principles 技能
  → 结果：需要拆解为 6 个子任务
  → 生成文件：task-details.md, task-details-test.md
```

**3. 状态日志**（进度）
```
[2025-01-30 11:35:00] [STATUS] Step 3: 执行中
  → 进度：子任务 2/6 (33%)
  → 当前任务：实现注册 API
  → 涉及文件：src/api/auth.js
```

**4. 错误日志**（失败和修复）
```
[2025-01-30 11:40:00] [ERROR] Step 4: 测试失败
  → 失败测试：testRegister()
  → 错误信息：AssertionError: Password validation failed
  → 调用 debug 技能...

[2025-01-30 11:42:30] [FIXED] 修复完成
  → 根因：密码验证逻辑错误（正则表达式不完整）
  → 修复：src/api/auth.js:45
  → 验证：✅ 所有测试通过
```

### 日志写入时机（强制执行）

```bash
# Step 1: 任务识别
echo "[$(date)] [DECISION] Step 1: ..." >> dev-flow.log

# Step 2: 任务分析
echo "[$(date)] [ACTION] Step 2: ..." >> dev-flow.log

# Step 3: 执行任务（每个子任务）
echo "[$(date)] [STATUS] Step 3: 子任务 X/Y ..." >> dev-flow.log

# Step 4: 测试验证
echo "[$(date)] [TEST] Step 4: 测试结果 ..." >> dev-flow.log

# Step 5: 错误处理（如果需要）
echo "[$(date)] [ERROR] Step 5: ..." >> dev-flow.log
echo "[$(date)] [FIXED] ..." >> dev-flow.log
```

**⚠️ 严禁跳过日志记录** - 每个步骤都必须记录日志

### 日志读取

```bash
# 查看完整日志
cat dev-flow.log

# 查看最近的执行
tail -n 50 dev-flow.log

# 查看错误日志
grep "\[ERROR\]" dev-flow.log

# 查看决策日志
grep "\[DECISION\]" dev-flow.log
```

---

## 📚 最佳实践

### 用户维护 tasks.md

**✅ 强制要求**：
- 保持 tasks.md 简洁，只记录任务标题
- 每次只关注 1-3 个任务（避免任务过多）
- 定期清理已完成的任务
- 使用清晰的描述："添加用户登录" 而不是 "做认证"

**❌ 严禁行为**：
- 在 tasks.md 中写详细的实现细节
- 一次添加 10+ 个任务
- 不更新任务状态
- **禁止未测试就标记任务完成**（核心规则）

### 任务拆解原则

✅ **好的拆解**：
- 每个子任务可以在 30 分钟内完成
- 子任务之间有清晰的依赖关系
- 每个子任务有明确的验收标准

❌ **避免的拆解**：
- 子任务太细碎（"打开文件"、"写一行代码"）
- 子任务太庞大（"实现后端"）
- 子任务之间没有逻辑关系

### 测试策略

**✅ 强制要求**：
- 至少包含 3 种测试方法
- 优先测试核心功能
- 测试应该可以自动化

**❌ 严禁行为**：
- 只依赖手动测试
- 测试覆盖不足
- 不测试边界情况
- **禁止跳过测试步骤直接标记完成**

---

## ⚙️ 配置选项

### 自动激活行为

默认情况下，dev-flow 会在以下情况自动激活：

```yaml
alwaysActivate: true  # 已在 frontmatter 中定义
```

**⚠️ 警告**：不建议禁用自动激活。

如果用户**不希望自动激活**，可以：

1. 修改 SKILL.md，移除 `alwaysActivate: true`
2. 或在对话中明确说明："不要自动激活 dev-flow"

### 自定义文件路径

如果用户想使用不同的文件名：

```
tasks.md → my-tasks.md
task-details.md → my-task-details.md
task-details-test.md → my-tests.md
```

可以在首次运行时指定，AI 会记住用户的偏好。

---

## 🎯 快速参考

### 五步流程

1. **Step 1**：读取 tasks.md → 找到任务
2. **Step 2**：判断清晰度 → 生成详细计划和测试方案
3. **Step 3**：执行任务 → 更新进度
4. **Step 4**：运行测试 → 验证功能
5. **Step 5**：调试错误 → 返回测试

### 关键文件

- `tasks.md` - 用户维护的主任务清单
- `task-details.md` - AI 维护的详细任务计划
- `task-details-test.md` - AI 维护的测试方案

### 协作技能

- `first-principles` - 任务拆解时调用
- `debug` - 测试失败时调用
- `dev-loop` - 长期项目时建议使用

---

**End of Dev Flow Skill**
