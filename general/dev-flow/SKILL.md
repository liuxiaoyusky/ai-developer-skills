---
name: dev-flow
description: 持久开发流程 - 管理开发任务的完整生命周期，包括任务识别、拆解、执行、测试和调试。适用于所有开发相关任务，提供系统化的任务追踪和验证机制。
alwaysActivate: true
---

# Dev Flow Skill

> **持久开发流程** - 一个自动激活的开发任务管理系统，提供从任务识别到验证测试的完整闭环。

---

## 🎯 技能概述

这是一个**自动激活**的开发流程技能，用于管理所有开发相关任务。它提供：

1. **任务识别** - 自动读取 tasks.md，找到待处理或进行中的任务
2. **智能拆解** - 使用第一性原理判断任务是否需要进一步拆解
3. **详细规划** - 生成 task-details.md 和 task-details-test.md
4. **执行追踪** - 标记进度，持续更新任务状态
5. **测试验证** - 按照测试方案验证功能
6. **错误处理** - 自动调用 debug 技能，记录错题本

### 自动激活条件

本技能在以下场景**自动激活**（无需用户显式调用）：

- 🟡 **中等信号**：用户提出开发任务/功能需求
- 🟡 **中等信号**：用户询问"如何实现"、"需要做什么"
- 🟡 **中等信号**：用户提到"开发"、"实现"、"添加功能"
- 🟢 **弱信号**（不激活）：纯技术问题咨询、代码解释

**用户手动激活**：
- "使用 dev-flow 技能"
- "开始开发流程"
- "管理我的开发任务"

---

## 📋 文件结构

```
project-root/
├── tasks.md                 # 主任务清单（用户维护）
├── task-details.md          # 当前任务的详细拆解（AI 维护）
├── task-details-test.md     # 当前任务的测试方案（AI 维护）
├── dev-flow.log             # 执行日志（AI 维护，实时追加）
└── .claude/
    └── debug-experiences/   # 调试经验（debug 技能维护）
```

### dev-flow.log 格式

实时记录执行过程，包含四类日志：

**1. 决策日志**（为什么这样选择）
```
[2025-01-30 11:32:15] [DECISION] Step 1: 任务识别
  → 找到任务"实现用户认证系统"
  → 优先级：无进行中任务，选择第一个待处理任务
```

**2. 行动日志**（做了什么）
```
[2025-01-30 11:32:20] [ACTION] Step 2: 任务分析
  → 调用 first-principles 技能
  → 分析结果：需要拆解为 6 个子任务
```

**3. 状态日志**（进度变化）
```
[2025-01-30 11:35:00] [STATUS] Step 3: 执行中
  → 子任务 2/6 (33%)
  → 当前：实现注册 API
```

**4. 错误日志**（失败和修复）
```
[2025-01-30 11:40:00] [ERROR] Step 4: 测试失败
  → 单元测试失败：testRegister()
  → 调用 debug 技能
  → 根因：密码验证逻辑错误
[2025-01-30 11:42:30] [FIXED] 修复完成
  → 修改文件：src/api/auth.js:45
  → 重新测试：✅ 通过
```

### tasks.md 格式（用户维护）

```markdown
# 开发任务清单

## 待处理 (TODO)

- [ ] 实现用户登录功能
- [ ] 添加数据导出功能
- [ ] 优化 API 性能

## 进行中 (IN PROGRESS)

- [ ] 修复支付模块 bug  # ← 如果有进行中任务，优先处理

## 已完成 (DONE)

- [x] 搭建项目基础架构
- [x] 配置开发环境
```

---

## 🔄 五步开发流程

### Step 1: 任务识别

**目标**：从 tasks.md 中找到当前要处理的任务

**执行流程**：

```bash
# 1. 读取 tasks.md
Read tasks.md

# 2. 任务优先级判断
优先级顺序：
  1. 进行中 (IN PROGRESS) 的任务 → 直接进入 Step 3
  2. 待处理 (TODO) 中的第一个任务 → 进入 Step 2
  3. 如果没有任务 → 询问用户是否需要添加新任务

# 3. 确认任务
AI: "📋 找到任务：<任务描述>
     这是你要处理的任务吗？[Y/n]"
```

**决策树**：

```
开始
  ↓
读取 tasks.md
  ↓
检查是否有"进行中"任务？
  ├─ YES → 显示任务 → 询问确认 → 进入 Step 3
  └─ NO  ↓
检查是否有"待处理"任务？
  ├─ YES → 显示第一个任务 → 询问确认 → 进入 Step 2
  └─ NO  ↓
询问用户是否添加新任务
```

---

### Step 2: 任务分析与拆解

**目标**：判断任务是否需要拆解，生成详细计划和测试方案

**2.1 任务清晰度判断**

**判断标准**：

```markdown
✅ **足够清晰**（直接执行）：
- 任务描述具体，有明确的验收标准
- 涉及文件 < 5 个
- 预计工作量 < 2 小时
- 不需要架构决策

示例：
- "添加用户注销按钮到导航栏"
- "修复 API 响应中的 CORS 错误"

❌ **需要拆解**（使用第一性原理）：
- 任务描述模糊，缺乏细节
- 涉及多个模块/子系统
- 需要架构设计或技术选型
- 预计工作量 > 2 小时

示例：
- "实现用户认证系统"  # 太宽泛
- "优化数据库性能"      # 缺乏具体目标
- "重构代码架构"        # 需要设计
```

**2.2 智能拆解流程（使用第一性原理）**

**调用 first-principles 技能**：

```
任务需要拆解
  ↓
调用 first-principles 技能
  ↓
第一性原理分析：
  1. 拆解到基本真理（核心目标是什么？）
  2. 质疑所有假设（哪些功能是必需的？）
  3. 从零重建方案（最小可行方案是什么？）
  ↓
生成 3-7 个子任务（按依赖关系排序）
  ↓
写入 task-details.md
```

**2.3 生成测试方案**

**测试策略**（至少 3 种）：

```markdown
### task-details-test.md 模板

# 测试方案：<任务名称>

## 1. 单元测试 (Unit Tests)
**目标**：验证核心逻辑正确性
**工具**：Jest / pytest / JUnit 等
**覆盖范围**：
- [ ] 核心函数的输入输出
- [ ] 边界条件和异常处理
- [ ] 状态变化逻辑

## 2. 集成/功能测试 (Integration Tests)
**目标**：验证功能正常工作
**方法**：
- [ ] 手动测试功能流程
- [ ] 验证与外部系统的交互
- [ ] 测试 API 接口

## 3. 启动和运行测试 (Startup Tests)
**目标**：确保应用可以正常启动
**验证项**：
- [ ] 应用可以启动无报错
- [ ] 前端页面可以正常加载
- [ ] 关键功能可以访问

## 4. 行为验证测试 (Behavior Tests)
**目标**：验证功能符合预期行为
**场景**：
- [ ] 正常场景：输入有效数据，验证输出
- [ ] 异常场景：输入无效数据，验证错误处理
- [ ] 边界场景：测试极限值

## 5. 性能/回归测试 (Performance Tests，可选)
**目标**：验证性能指标或防止功能退化
**指标**：
- [ ] 响应时间 < X ms
- [ ] 内存占用 < Y MB
- [ ] 通过现有测试套件
```

**2.4 生成详细任务文件**

**task-details.md 模板**：

```markdown
# 详细任务：<任务名称>

## 任务概述
- **原始任务**：<来自 tasks.md 的描述>
- **清晰度评估**：足够清晰 / 需要拆解
- **预计工作量**：X 小时

## 子任务列表（如果需要拆解）

### 子任务 1：[标题]
**状态**：pending / in_progress / completed
**描述**：...
**涉及文件**：...
**验收标准**：...

### 子任务 2：[标题]
**状态**：pending
**描述**：...

## 执行计划
1. 分析现有代码（阅读相关文件）
2. 实现核心功能
3. 添加错误处理
4. 编写/更新文档

## 涉及文件
- `src/components/UserAuth.jsx` - 需要修改
- `src/api/auth.js` - 需要添加新方法

## 依赖项
- 需要先完成：...
- 需要安装：...

## 验收标准
- [ ] 功能正常工作
- [ ] 通过所有测试
- [ ] 代码已提交

## 进度追踪
开始时间：YYYY-MM-DD HH:mm
当前子任务：子任务 1
完成度：0%
```

**写入文件**：

```bash
# 覆盖写入 task-details.md
Write task-details.md

# 覆盖写入 task-details-test.md
Write task-details-test.md
```

---

### Step 3: 执行任务

**目标**：按照 task-details.md 执行任务，实时更新进度

**执行流程**：

```markdown
## 3.1 预备阶段

### 读取相关文件
使用 Read 工具阅读：
- task-details.md 中的"涉及文件"
- 相关的配置文件
- 依赖的模块

### 理解现有实现
- 使用 Grep 搜索相关代码模式
- 使用 Glob 查找相关文件
- 了解项目结构和约定

## 3.2 执行阶段

### 按子任务顺序执行
对于每个子任务：
  1. 标记为 in_progress
  2. 执行实现（使用 Edit/Write 工具）
  3. 更新 task-details.md 中的进度
  4. 标记为 completed

### 进度更新格式
在 task-details.md 中更新：
```markdown
## 进度追踪
开始时间：YYYY-MM-DD HH:mm
当前子任务：子任务 2 / 共 5 个
完成度：40%（2/5 子任务完成）

最近更新：
- [✓] 子任务 1：实现用户登录 UI (已完成)
- [→] 子任务 2：实现 API 调用逻辑 (进行中)
- [ ] 子任务 3：添加错误处理
```

## 3.3 任务完成信号

当所有子任务完成后：
AI: "✅ 任务执行完成！
     完成子任务：5/5
     完成时间：YYYY-MM-DD HH:mm
     总耗时：X 小时

     接下来进入测试阶段 (Step 4)..."
```

**工具使用策略**：

```markdown
✅ 推荐工具：
- Read  - 阅读现有代码
- Edit  - 修改代码（优先使用）
- Write - 创建新文件
- Grep  - 搜索相关代码
- Glob  - 查找文件

❌ 避免使用：
- Bash echo - 使用文本回复代替
- sed/awk  - 使用 Edit 工具代替
```

---

### Step 4: 测试验证

**目标**：按照 task-details-test.md 验证功能

**测试执行流程**：

```markdown
## 4.1 读取测试方案

Read task-details-test.md

## 4.2 逐项测试

### 对于每个测试项：

1. **单元测试**
   ```bash
   # 运行单元测试
   npm test

   # 或运行特定测试
   pytest tests/test_auth.py
   ```

   **结果判断**：
   - ✅ 通过 → 继续下一个测试
   - ❌ 失败 → 进入 Step 5（调试）

2. **启动和运行测试**
   ```bash
   # 启动应用
   npm run dev

   # 或构建并运行
   npm run build && npm start
   ```

   **验证项**：
   - [ ] 应用启动无报错
   - [ ] 可以访问主页面
   - [ ] 浏览器控制台无错误

   **结果判断**：
   - ✅ 通过 → 继续下一个测试
   - ❌ 失败 → 进入 Step 5（调试）

3. **功能行为测试**
   ```bash
   # 手动测试或使用自动化测试
   # 验证功能符合预期
   ```

   **验证项**：
   - [ ] 正常场景测试
   - [ ] 异常场景测试
   - [ ] 边界条件测试

   **结果判断**：
   - ✅ 通过 → 继续下一个测试
   - ❌ 失败 → 进入 Step 5（调试）

## 4.3 测试结果汇总

AI: "📊 测试结果汇总：

     ✅ 单元测试：通过 (15/15)
     ✅ 启动测试：通过
     ✅ 功能测试：通过 (8/8 测试场景)

     总体结果：全部通过 ✓

     任务完成！已更新 tasks.md"
```

**更新 tasks.md**：

```markdown
# 在 tasks.md 中移动任务

## 进行中 (IN PROGRESS)
(移除已完成的任务)

## 已完成 (DONE)
- [x] <完成的任务描述>  # 完成时间：YYYY-MM-DD
```

---

### Step 5: 错误处理与调试

**目标**：当测试失败时，系统化地解决问题

**触发条件**：
- Step 4 中任意测试失败
- 运行时错误/异常
- 功能不符合预期

**执行流程**：

```markdown
## 5.1 错误分类

检测到错误，进入调试流程：

1. **记录错误信息**
   ```markdown
   ### task-details-test.md（追加）

   ## 错误记录

   ### 错误 1
   **时间**：YYYY-MM-DD HH:mm
   **测试项**：单元测试 - 测试登录功能
   **错误信息**：...
   **堆栈跟踪**：...
   **复现步骤**：...
   ```

2. **自动激活 debug 技能**
   ```
   调用 debug 技能，提供以下信息：
   - 错误描述
   - 错误日志
   - 当前任务上下文
   ```

## 5.2 Debug 执行

Debug 技能将：
1. 使用 5 Whys 或第一性原理分析根因
2. 提供解决方案
3. 自动记录到 `.claude/debug-experiences/`

## 5.3 修复验证

修复后重新运行测试：
```bash
# 重新运行失败的测试
npm test -- --testNamePattern="failing test"

# 或重新运行所有测试
npm test
```

**循环**：
- 如果修复成功 → 返回 Step 4 继续测试
- 如果仍然失败 → 重复 Step 5

## 5.4 完成信号

AI: "🔧 问题已修复！

     根因：...
     解决方案：...
     已记录到错题集：.claude/debug-experiences/YYYY-MM-DD-issue.md

     重新测试中...
     ✅ 所有测试通过

     返回 Step 4 继续验证..."
```

---

## 🎯 完整流程图

```
┌─────────────────────────────────────────────────────────────┐
│                    用户请求/自动激活                          │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 1: 任务识别                                            │
│  ├─ 读取 tasks.md                                            │
│  ├─ 优先级判断 (IN PROGRESS > TODO)                          │
│  └─ 确认任务                                                 │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 2: 任务分析与拆解                                      │
│  ├─ 判断清晰度                                               │
│  ├─ 如果需要拆解 → 调用 first-principles                     │
│  ├─ 生成 task-details.md                                     │
│  └─ 生成 task-details-test.md                                │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 3: 执行任务                                            │
│  ├─ 按子任务顺序执行                                         │
│  ├─ 实时更新进度                                             │
│  └─ 标记完成状态                                             │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 4: 测试验证                                            │
│  ├─ 读取 task-details-test.md                                │
│  ├─ 逐项执行测试                                             │
│  ├─ 如果全部通过 → 完成，更新 tasks.md                       │
│  └─ 如果有失败 → 进入 Step 5                                 │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 5: 错误处理                                            │
│  ├─ 记录错误信息                                             │
│  ├─ 调用 debug 技能                                          │
│  ├─ 修复问题                                                 │
│  └─ 返回 Step 4 重新测试                                     │
└─────────────────────────────────────────────────────────────┘
```

---

## 📝 使用示例

### 示例 1：清晰任务（无需拆解）

**用户**：帮我添加一个用户注销按钮

**AI 流程**：

```
Step 1: 读取 tasks.md
  → 找到任务："- [ ] 添加用户注销按钮"
  → 确认：这是你要处理的任务吗？[Y/n]

Step 2: 判断清晰度
  → 任务描述具体，涉及文件少
  → 评估：足够清晰，无需拆解
  → 生成 task-details.md（单任务）
  → 生成 task-details-test.md

Step 3: 执行任务
  → 读取导航栏组件
  → 添加注销按钮
  → 实现注销逻辑
  → 更新进度：100%

Step 4: 测试验证
  → 运行单元测试：✅ 通过
  → 启动应用：✅ 正常
  → 手动测试注销功能：✅ 正常

  → 更新 tasks.md：移动到 DONE
```

### 示例 2：复杂任务（需要拆解）

**用户**：帮我实现用户认证系统

**AI 流程**：

```
Step 1: 读取 tasks.md
  → 找到任务："- [ ] 实现用户认证系统"
  → 确认：这是你要处理的任务吗？[Y/n]

Step 2: 判断清晰度
  → 任务描述宽泛，涉及多个模块
  → 评估：需要拆解

  → 调用 first-principles 技能

  → 第一性原理分析：
      基本真理：
      - 认证的核心目标是验证用户身份
      - 最小可行方案：注册 + 登录 + 注销

      质疑假设：
      - 是否需要社交登录？→ MVP 不需要
      - 是否需要双因素认证？→ MVP 不需要
      - 是否需要密码重置？→ 暂时不需要

      重建方案：
      1. 设计数据库表结构（users 表）
      2. 实现注册 API
      3. 实现登录 API
      4. 实现前端认证表单
      5. 实现注销功能
      6. 添加认证中间件

  → 生成 task-details.md（6 个子任务）
  → 生成 task-details-test.md

Step 3: 执行任务
  → 子任务 1：设计数据库表结构 [in_progress]
  → 子任务 1：设计数据库表结构 [completed]
  → 子任务 2：实现注册 API [in_progress]
  → 子任务 2：实现注册 API [completed]
  → ... (继续执行)

Step 4: 测试验证
  → 单元测试：✅ 通过
  → 集成测试：❌ 失败
  → 进入 Step 5

Step 5: 错误处理
  → 调用 debug 技能
  → 根因分析：API 响应格式不匹配
  → 修复问题
  → 返回 Step 4 重新测试

  → 所有测试通过 ✅
  → 更新 tasks.md：移动到 DONE
```

---

## 🛠️ 与其他技能的协作

### Dev Flow + First-Principles

```
Step 2: 任务需要拆解
  ↓
调用 first-principles 技能
  - 第一性原理分析
  - 生成子任务列表
  ↓
返回 dev-flow，写入 task-details.md
```

### Dev Flow + Debug

```
Step 4: 测试失败
  ↓
Step 5: 调用 debug 技能
  - 5 Whys 根因分析
  - 提供解决方案
  - 记录到错题集
  ↓
修复完成，返回 Step 4 重新测试
```

### Dev Flow + Ralph Loop

**第一性原理设计**：每次完整的 Dev Flow 执行 = 一个迭代

```
传统方式（已弃用）：
ralph-loop 调用自己 → 实现细节

第一性原理方式（推荐）：
ralph-loop 调用 dev-flow → 标准化流程
```

**架构对比**：

```
┌─────────────────────────────────────────────────────────────┐
│  传统 Ralph Loop（直接实现）                                  │
├─────────────────────────────────────────────────────────────┤
│  loop.sh:                                                   │
│    while cat TASKS.md | grep -q "^\- \[ \]"; do             │
│      claude "继续下一个任务"                                  │
│    done                                                     │
│                                                              │
│  问题：                                                       │
│  - 每次执行逻辑不一致                                         │
│  - 没有标准化流程                                             │
│  - 难以追踪和调试                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│  新方式：Ralph Loop → Dev Flow（推荐）                        │
├─────────────────────────────────────────────────────────────┤
│  loop.sh:                                                   │
│    while cat tasks.md | grep -q "^\- \[ \]"; do             │
│      claude "使用 dev-flow 处理tasks.md中正在执行的任务或者下一个未完成的任务"  # 每个 CLI 调用  │
│    done                                                     │
│           = 1 次 dev-flow 执行（5 步闭环）                     │
│                                                              │
│  优势：                                                       │
│  ✓ 每次执行都是标准化流程（5 步）                              │
│  ✓ 自动日志记录（dev-flow.log）                              │
│  ✓ 集成 first-principles + debug                             │
│  ✓ 可预测、可调试、可恢复                                      │
└─────────────────────────────────────────────────────────────┘
```

**使用场景**：

```bash
# 场景 1：单次开发任务（手动）
claude "使用 dev-flow 技能"
→ 执行一次完整的 5 步流程
→ 完成后退出

# 场景 2：长期项目（自动迭代）
# 创建 loop.sh：
while cat tasks.md | grep -q "^\- \[ \]"; do
  claude "使用 dev-flow 技能处理下一个任务"
  # 每次 CLI 调用 = 1 次 dev-flow 执行
  # 包括：识别 → 拆解 → 执行 → 测试 → 调试
done

# 运行：
bash loop.sh
```

**迭代语义**：

```
1 次迭代 = 1 次 CLI 调用 = 1 次 dev-flow 执行
  ↓
包括完整的 5 步：
  - Step 1: 读取 tasks.md，找到下一个任务
  - Step 2: 分析拆解（调用 first-principles）
  - Step 3: 执行任务（实时更新进度）
  - Step 4: 测试验证
  - Step 5: 错误处理（调用 debug）
  - 成功：更新 tasks.md，任务移到 DONE
  - 失败：保持在 TODO，下次继续
  ↓
CLI 退出，loop.sh 继续下一次迭代
```

**可行性验证**：✅ **可信**

| 维度 | 传统 Ralph Loop | Ralph Loop + Dev Flow |
|------|-----------------|----------------------|
| 流程标准化 | ❌ 随意性强 | ✅ 5 步固定流程 |
| 可调试性 | ❌ 难以追踪 | ✅ dev-flow.log |
| 错误处理 | ❌ 手动 | ✅ 自动调用 debug |
| 任务拆解 | ❌ 依赖随机性 | ✅ first-principles |
| 测试验证 | ❌ 可能跳过 | ✅ 强制测试 |
| 可恢复性 | ❌ 困难 | ✅ 状态清晰 |

### 完整技能栈

| 场景 | 主要技能 | 协作技能 |
|---|---|---|
| 简单开发任务 | dev-flow | - |
| 复杂任务拆解 | dev-flow | first-principles |
| 任务调试 | dev-flow | debug |
| 长期项目 | **ralph-loop → dev-flow** | debug, first-principles |
| 代码审查 | linus-code-review | - |

**关键变化**：ralph-loop 不再直接实现任务，而是调用 dev-flow 执行标准化流程。

---

## 📊 执行日志系统

### 日志机制

Dev Flow 在执行过程中会实时追加日志到 `dev-flow.log`，包含：

**1. 决策日志**（为什么）
```
[2025-01-30 11:32:15] [DECISION] Step 1: 任务识别
  → 找到任务"实现用户认证系统"
  → 理由：无进行中任务，选择第一个待处理任务
```

**2. 行动日志**（做了什么）
```
[2025-01-30 11:32:20] [ACTION] Step 2: 任务分析
  → 调用 first-principles 技能
  → 结果：需要拆解为 6 个子任务
  → 生成文件：task-details.md, task-details-test.md
```

**3. 状态日志**（进度）
```
[2025-01-30 11:35:00] [STATUS] Step 3: 执行中
  → 进度：子任务 2/6 (33%)
  → 当前任务：实现注册 API
  → 涉及文件：src/api/auth.js
```

**4. 错误日志**（失败和修复）
```
[2025-01-30 11:40:00] [ERROR] Step 4: 测试失败
  → 失败测试：testRegister()
  → 错误信息：AssertionError: Password validation failed
  → 调用 debug 技能...

[2025-01-30 11:42:30] [FIXED] 修复完成
  → 根因：密码验证逻辑错误（正则表达式不完整）
  → 修复：src/api/auth.js:45
  → 验证：✅ 所有测试通过
```

### 日志写入时机

```bash
# Step 1: 任务识别
echo "[$(date)] [DECISION] Step 1: ..." >> dev-flow.log

# Step 2: 任务分析
echo "[$(date)] [ACTION] Step 2: ..." >> dev-flow.log

# Step 3: 执行任务（每个子任务）
echo "[$(date)] [STATUS] Step 3: 子任务 X/Y ..." >> dev-flow.log

# Step 4: 测试验证
echo "[$(date)] [TEST] Step 4: 测试结果 ..." >> dev-flow.log

# Step 5: 错误处理（如果需要）
echo "[$(date)] [ERROR] Step 5: ..." >> dev-flow.log
echo "[$(date)] [FIXED] ..." >> dev-flow.log
```

### 日志读取

```bash
# 查看完整日志
cat dev-flow.log

# 查看最近的执行
tail -n 50 dev-flow.log

# 查看错误日志
grep "\[ERROR\]" dev-flow.log

# 查看决策日志
grep "\[DECISION\]" dev-flow.log
```

---

## 📚 最佳实践

### 用户维护 tasks.md

✅ **推荐做法**：
- 保持 tasks.md 简洁，只记录任务标题
- 每次只关注 1-3 个任务（避免任务过多）
- 定期清理已完成的任务
- 使用清晰的描述："添加用户登录" 而不是 "做认证"

❌ **避免**：
- 在 tasks.md 中写详细的实现细节
- 一次添加 10+ 个任务
- 不更新任务状态

### 任务拆解原则

✅ **好的拆解**：
- 每个子任务可以在 30 分钟内完成
- 子任务之间有清晰的依赖关系
- 每个子任务有明确的验收标准

❌ **避免的拆解**：
- 子任务太细碎（"打开文件"、"写一行代码"）
- 子任务太庞大（"实现后端"）
- 子任务之间没有逻辑关系

### 测试策略

✅ **推荐**：
- 至少包含 3 种测试方法
- 优先测试核心功能
- 测试应该可以自动化

❌ **避免**：
- 只依赖手动测试
- 测试覆盖不足
- 不测试边界情况

---

## ⚙️ 配置选项

### 自动激活行为

默认情况下，dev-flow 会在以下情况自动激活：

```yaml
alwaysActivate: true  # 已在 frontmatter 中定义
```

如果用户**不希望自动激活**，可以：

1. 修改 SKILL.md，移除 `alwaysActivate: true`
2. 或在对话中明确说明："不要自动激活 dev-flow"

### 自定义文件路径

如果用户想使用不同的文件名：

```
tasks.md → my-tasks.md
task-details.md → my-task-details.md
task-details-test.md → my-tests.md
```

可以在首次运行时指定，AI 会记住用户的偏好。

---

## 🎯 快速参考

### 五步流程

1. **Step 1**：读取 tasks.md → 找到任务
2. **Step 2**：判断清晰度 → 生成详细计划和测试方案
3. **Step 3**：执行任务 → 更新进度
4. **Step 4**：运行测试 → 验证功能
5. **Step 5**：调试错误 → 返回测试

### 关键文件

- `tasks.md` - 用户维护的主任务清单
- `task-details.md` - AI 维护的详细任务计划
- `task-details-test.md` - AI 维护的测试方案

### 协作技能

- `first-principles` - 任务拆解时调用
- `debug` - 测试失败时调用
- `ralph-loop` - 长期项目时建议使用

---

**End of Dev Flow Skill**
